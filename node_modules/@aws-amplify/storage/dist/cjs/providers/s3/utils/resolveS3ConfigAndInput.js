'use strict';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveS3ConfigAndInput = void 0;
const assertValidationError_1 = require("../../../errors/utils/assertValidationError");
const validation_1 = require("../../../errors/types/validation");
const resolvePrefix_1 = require("../../../utils/resolvePrefix");
const constants_1 = require("./constants");
/**
 * resolve the common input options for S3 API handlers from Amplify configuration and library options.
 *
 * @param {AmplifyClassV6} amplify The Amplify instance.
 * @param {S3ApiOptions} apiOptions The input options for S3 provider.
 * @returns {Promise<ResolvedS3ConfigAndInput>} The resolved common input options for S3 API handlers.
 * @throws A {@link StorageError} with `error.name` from {@link StorageValidationErrorCode} indicating invalid
 *   configurations or Amplify library options.
 *
 * @internal
 */
const resolveS3ConfigAndInput = async (amplify, apiOptions) => {
    // identityId is always cached in memory if forceRefresh is not set. So we can safely make calls here.
    const { credentials, identityId } = await amplify.Auth.fetchAuthSession({
        forceRefresh: false,
    });
    (0, assertValidationError_1.assertValidationError)(!!credentials, validation_1.StorageValidationErrorCode.NoCredentials);
    (0, assertValidationError_1.assertValidationError)(!!identityId, validation_1.StorageValidationErrorCode.NoIdentityId);
    const { bucket, region, dangerouslyConnectToHttpEndpointForTesting } = amplify.getConfig()?.Storage?.S3 ?? {};
    (0, assertValidationError_1.assertValidationError)(!!bucket, validation_1.StorageValidationErrorCode.NoBucket);
    (0, assertValidationError_1.assertValidationError)(!!region, validation_1.StorageValidationErrorCode.NoRegion);
    const { defaultAccessLevel, prefixResolver = resolvePrefix_1.resolvePrefix, isObjectLockEnabled, } = amplify.libraryOptions?.Storage?.S3 ?? {};
    const keyPrefix = await prefixResolver({
        accessLevel: apiOptions?.accessLevel ?? defaultAccessLevel ?? constants_1.DEFAULT_ACCESS_LEVEL,
        // use conditional assign to make tsc happy because StorageOptions is a union type that may not have targetIdentityId
        targetIdentityId: apiOptions?.accessLevel === 'protected'
            ? apiOptions?.targetIdentityId ?? identityId
            : identityId,
    });
    return {
        s3Config: {
            credentials,
            region,
            useAccelerateEndpoint: apiOptions?.useAccelerateEndpoint,
            ...(dangerouslyConnectToHttpEndpointForTesting
                ? {
                    customEndpoint: constants_1.LOCAL_TESTING_S3_ENDPOINT,
                    forcePathStyle: true,
                }
                : {}),
        },
        bucket,
        keyPrefix,
        isObjectLockEnabled,
    };
};
exports.resolveS3ConfigAndInput = resolveS3ConfigAndInput;
//# sourceMappingURL=resolveS3ConfigAndInput.js.map
